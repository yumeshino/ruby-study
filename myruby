[Ruby] pryやirbで日本語入力を可能にする

rbenv利用時の場合
# 適用したいrubyバージョンが既にインストール済みの場合は一度uninstall
$ rbenv uninstall 2.1.1

# readlineのinstall
$ brew install readline
$ brew link readline --force

# readlineを利用してruby再install
$ RUBY_CONFIGURE_OPTS="--with-readline-dir=$(brew --prefix readline)"
$ rbenv install 2.1.1
これで日本語入力可能に。
$ pry
[1] pry(main)> 'ぷらい'
=> "ぷらい"

$ irb
irb(main):001:0> 'あいあーるびー'
=> "あいあーるびー"

pryやirbはREPLと呼ぶ
->Lead、リーバル、Printloopの略で入力されたコードを読んで評価して表示することを繰り返すツール
pryはコードをカラーリングしたり自動t形にインデントをいれて読むやすくしてくれる

コンパイル
コンパイルとは、特定のプログラミング言語を用いて記述されたコンピュータープログラムを他の言語 (普通はコンピューターが実行できるバイナリ言語) を用いて記述された同じプログラムに形を変えることである。


rubyの特徴
・インタプリタ型言語
  →プログラマーが明示的にソースコードをコンパイルスルスル作業がない
    実際にコードを実行するタイミングで逐一機械語にコンパイルしてくれるため
    手軽にコードを実行して結果を確認することができる
・オブジェクト指向言語
・構文の自由度が高い

stringオブジェクトの解説
・rubyではオブジェクトがなんのクラスであるかをクラスメソッドで確認することができる
・直接記述できる値のことをリテラルと呼ぶ。リテラルで書く以外にstringクラスからオブジェクトを生成することもできる
・オブジェクトに備わったメソッドを呼び出すにはオブジェクトの後ろにドットをつけて続けてメソッド名を繋げる
・一般的なプログラミング言語ではメソッドを呼び出す際にかっこをつける物が多いがrubyはかっこを省略することができる。rubyでは引数がないメソッドはかっこは省略するのが望ましい
・pryでは変数名を入力してenterを押すことで変数の中身を確認することができる
・rubyでは別のクラスのオブジェクトに変換する場合にtoから始まるメソッドが用意されている。他のクラスのオブジェクトに変換することで変換後のクラスに実装されたメソッドや構文を使用することができる
・<＜を使って文字を連結させた場合には変数の中身の文字列も変更される。同じことを＋演算子で行うには連結した結果を変数に代入する
・文字列の中の式を展開するには文字列をダブルクォートで括る必要がある
  [4] pry(main)> two = '二'
  => "二"
    [5] pry(main)> "1 + 1は#{two}"
  => "1 + 1は二"
  

クラス
オブジェクトの元となる雛形

オブジェクト
データと指定の処理を行うメソッドをまとめたもの

メソッド
特定の処理を行う機能のこと

レシーバ
レシーバーは特に Ruby の用語というわけではなく、オブジェクト指向一般に使われる用語です。
意味は「 . の左側」で間違いありません。
例えば以下の例では car が run メソッドのレシーバーとなります。
car.run

stringオブジェクト
文字列を扱うオブジェクト
文字列の場合はstringクラスを元にオブジェクトが作成されstringクラスの定義された機能を呼び出すことができる

methodsメソッド
レシーバのオブジェクトが持つメソッドを表示してくれる
メソッド名を忘れてしまった場合やどんなメソッドが実装せれているのかを知りたい場合に利用できる
-----------------------------------------------------------------------------
Symbolオブジェクト
ruby独自のオブジェクト
使うときは頭にコロンをつける。ソースコード上では文字列のように見えるがrubyの内部では整数として扱われる。内部では整数として処理することで高速に処理することができる。同じシンボル名は同じオブジェクトを指すためメモリの使用率を抑えるkとができる

ハッシュ
ハッシュは配列と同じく複数のオブジェクトへの参照をまとめて管理することが出来るオブジェクトです。配列と大きく異なる点は、配列がインデックスを使って要素を区別していたのに対し、ハッシュではキーと呼ばれるものを使用します。
--------------------------------------------------------------------------
リテラル
数字の1や文字列"hello world"のようにRubyのプログラムの中に直接記述できる値の事をリテラルといいます。

ブロック
ブロックとはメソッドの呼び出しの際に渡すことができる処理のかたまり
[1] pry(main)> 3.times do |i|
[1] pry(main)*   puts i
[1] pry(main)* end
0
1
2
=> 3
上記の例だとdo〜endまでがひとかたまりの処理でこれをブロックという
timesオブジェクトではIntegerオブジェクトの数だけ渡したブロックが繰り返し実行されブロックの引数には一から順に数字が渡される

[2] pry(main)> 3.times { |num| puts num }
0
1
2
=> 3
上記のようにdo〜endの代わりにか{}を使用しても同じ意味になる
複数行にまたがる処理を含むブロックの場合はdo-endを使用し、1行だけの短い時間処理の場合には{}を使用するのが好ましい



Integer, Floatオブジェクト
数字のリテラル。整数、１（Integer）。小数、1.5（Float）
数字リテラルは四則演算を行うことができる


・IntegerとFloatで計算を行った結果はFloatオブジェクトになる
・Floatでは小数点以下を四捨五入したり切り上げ切り下げするメソッドが用意されている


Enumeratorオブジェクト
Integerオブジェクトはtimeメソッドを使うことでEnumeratorオブジェクトを生成する
Enumeratorを使用することで指定回数、同じ処理を繰り返すことができる
[6] pry(main)> 3.times
=> #<Enumerator: ...>
-------------------------------------------------------------------------------
Array
一般的に配列とも呼ばれている

要素
arrayオブジェクト内の各データのことを要素と呼ぶ

Arrayオブジェクト
複数のオブジェクトを格納できるオブジェクト
[1] pry(main)> []
=> []
[2] pry(main)> [1,2,3]
=> [1, 2, 3]
[3] pry(main)>
異なるクラスのオブジェクトを混在して格納することもできる
[3] pry(main)> [1,'日本',1.5]
=> [1, "日本", 1.5]



%w記法
下の二つは同じ意味
[4] pry(main)> ['文','字']
=> ["文", "字"]
[5] pry(main)> %w[文 字]
=> ["文", "字"]
このように％wの記法の場合は文字をシングルクォートで囲う必要がなく各文字をカンマで区切る代わりにスペースで区切る
w（小文字）・・・シングルクォートで囲ったのと同じ意味になる
W（大文字）・・・ダブルクォートで括ったのと同じ動作になる
                  変数を展開することもできる
[4] pry(main)> one = 1
=> 1
[5] pry(main)> two = 2
=> 2
[6] pry(main)> %W[a#{one} b#{two}]
=> ["a1", "b2"]

Symbolの配列には%iを使する
[7] pry(main)> %i[a b c]
=> [:a, :b, :c]
文字列やsymbolのデータで配列を初期化する場合には積極的に%記法を使う

繰り返し処理

eachメソッド
arrayオブジェクトのeachメソッドを呼び出しブロックを渡すと配列の各要素を取り出して処理を行うことができる
[1] pry(main)> %w[あ い う].each do |str|
[1] pry(main)*   puts str
[1] pry(main)* end
あ
い
う
=> ["あ", "い", "う"]

breakメソッド
breakを使って途中で終了させることができる
[2] pry(main)> %w[あ い う].each do |str|
[2] pry(main)*   break if str =='う'
[2] pry(main)*   puts str
[2] pry(main)* end
あ
い
=> nil

nextメソッド
一文だけスキップさせたい場合に使う
[3] pry(main)> %w[あ い う].each do |str|
[3] pry(main)*   next if str =='い'
[3] pry(main)*   puts str
[3] pry(main)* end
あ
う
=> ["あ", "い", "う"]

mapメソッド
各要素を格納した配列を作ることができる
mapはブロック内で開始した値を集めて新しい配列を返す
一般的な言語では戻り値を値で返す場合にはreturnを使用する物が多いがrubyではブロックの最終行の式の結果が自動的に戻り値として返されるためreturnを省略することができる
[2] pry(main)> %w[あ い う].map { |str| "(#{str})" }
=> ["(あ)", "(い)", "(う)"]

多重配列
配列の各要素は個々の変数に格納することができる
[1] pry(main)> foo,bar = [1,2]
=> [1, 2]
[2] pry(main)> foo
=> 1
[3] pry(main)> bar
=> 2

配列にせずに値をカンマ区切りで並べることでも各変数に格納できる 
[4] pry(main)> foo,bar = 1,2
=> [1, 2]
[5] pry(main)> foo
=> 1
[6] pry(main)> bar
=> 2

右側の値が足りない場合は変数にnilが格納される
[7] pry(main)> foo,bar = 1
=> 1
[8] pry(main)> foo
=> 1
[9] pry(main)> bar
=> nil
-----------------------------------------------------
Hashオブジェクト
キーとバリューの組み合わせで表現できるオブジェクト

任意の数のキーとバリューををもたせることができる
[11] pry(main)> user1 = {name: '一郎'}
=> {:name=>"一郎"}
[12] pry(main)> user2 = {id: 2, name: '二郎'}
=> {:id=>2, :name=>"二郎"}

キー名にコロンをつけた形でデータを定義した場合はキーの部分がsymbolになる
[13] pry(main)> user1[:name]
=> "一郎"
[14] pry(main)> user2[:id]
=> 2
[15] pry(main)> user2[:name]
=> "二郎"

この書き方ではキーをstringで指定しても値を参照できない
[16] pry(main)> user1['name']
=> nil
明示的にキーをstringで表す必要がある場合には次のように書く
[17] pry(main)> user3 = { 'id' =>3, 'name' =>'三郎' }
=> {"id"=>3, "name"=>"三郎"}
[18] pry(main)> user3['id']
=> 3
[19] pry(main)> user3['name']
=> "三郎"

バリューの部分には任意のオブジェクトを入れることができるのでhashで階層構造を作ることができる
[3] pry(main)> user4 = {
[3] pry(main)*   name: '四郎',
[3] pry(main)*   test_result: {
[3] pry(main)*     math: 70,
[3] pry(main)*     science: 80
[3] pry(main)*   }
[3] pry(main)* }
=> {:name=>"四郎", :test_result=>{:math=>70, :science=>80}}
[4] pry(main)> user4[:test_result][:math]
=> 70

特定のキーの位置に値を代入することで値を書き換えることができる
[5] pry(main)> user4[:test_result][:math] = 90
=> 90
[6] pry(main)> user4
=> {:name=>"四郎", :test_result=>{:math=>90, :science=>80}}

keysメソッド・valuesメソッド
Hashオブジェクトではkeysメソッドでキーの配列、valueメソッドで値の配列を取得することができる
=> [:name, :test_result]
[8] pry(main)> user4.values
=> ["四郎", {:math=>90, :science=>80}]

Hashオブジェクトでもeachメソッドを呼び出すことができ、Hashのeachメソッドではブロックに2つの値が渡される。1つ目がキーの値で2つ目がバリューの値
[9] pry(main)> user4.each do |k, v|
[9] pry(main)*   puts "#{k} = #{v}"
[9] pry(main)* end
name = 四郎
test_result = {:math=>90, :science=>80}
=> {:name=>"四郎", :test_result=>{:math=>90, :science=>80}}

一部のキーバリューを削除するにはdeleteメソッドで第一引数に削除対象のキーを指定する
[10] pry(main)> user4.delete(:test_result)
=> {:math=>90, :science=>80}
[11] pry(main)> user4
=> {:name=>"四郎"}
-------------------------------------------------------------
Rangeオブジェクト
Rangeオブジェクトはある値の範囲を扱うためのオブジェクト
[12] pry(main)> 1..3
=> 1..3
[13] pry(main)> (1..3).class
=> Range

ドットを3つにすることで最後の値は含まないレンジになる
[14] pry(main)> (1...3).to_a
=> [1, 2]
.to_aメソッドでArrayオブジェクトに変換できる

アルファベットの並びも作成できる
[15] pry(main)> ('a'..'z').to_a
=> ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]

Rangeオブジェクトでもeachメソッドで各値を取り出して処理を行うことができる
[16] pry(main)> (1..31).each { |day| puts "#{day}日" }
1日
2日
3日
4日
5日
6日
7日
8日
9日
10日
11日
12日
13日
14日
15日
16日
17日
18日
19日
20日
21日
22日
23日
24日
25日
26日
27日
28日
29日
30日
31日
=> 1..31





